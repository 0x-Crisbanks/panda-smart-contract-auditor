"""
Security Report Generator for Solidity Smart Contract Audits

This module generates professional security audit reports in Markdown and JSON formats.
The reports follow industry standards and include detailed vulnerability explanations,
recommendations, and educational content.

EDUCATIONAL PURPOSE: This tool is designed for learning about smart contract security
and should only be used for authorized security assessments and educational purposes.
"""

import hashlib
from datetime import datetime
from typing import List, Dict, Optional
from detectors import Finding


class SecurityReporter:
    """
    Generates comprehensive security audit reports for smart contract analysis.
    
    This class creates professional-quality reports that include executive summaries,
    detailed findings, remediation recommendations, and educational content about
    smart contract security best practices.
    """
    
    def __init__(self):
        self.tool_version = "1.0.0"
        self.tool_name = "Solidity Security Auditor"
    
    def generate_report(self, code: str, findings: List[Finding], source: str, code_hash: str) -> str:
        """
        Generate a comprehensive security audit report in Markdown format.
        
        Args:
            code: The analyzed Solidity source code
            findings: List of security findings from the analysis
            source: Description of the code source (file path, clipboard, etc.)
            code_hash: SHA256 hash of the analyzed code
            
        Returns:
            Formatted Markdown report as a string
        """
        timestamp = datetime.now()
        
        # Build report sections
        report_sections = [
            self._generate_header(timestamp, source, code_hash),
            self._generate_disclaimer(),
            self._generate_executive_summary(findings),
            self._generate_scope_section(source, code),
            self._generate_methodology_section(),
            self._generate_findings_section(findings),
            self._generate_recommendations_section(findings),
            self._generate_references_section(),
            self._generate_appendix_section(code, code_hash)
        ]
        
        return '\n\n'.join(report_sections)
    
    def _generate_header(self, timestamp: datetime, source: str, code_hash: str) -> str:
        """Generate the report header with metadata."""
        return f"""# Smart Contract Security Audit Report

**Generated by:** {self.tool_name} v{self.tool_version}  
**Date:** {timestamp.strftime('%Y-%m-%d %H:%M:%S UTC')}  
**Auditor:** Automated Security Analysis Tool  
**Source:** {source}  
**Code Hash:** `{code_hash}`  

---"""
    
    def _generate_disclaimer(self) -> str:
        """Generate ethical use disclaimer."""
        return """## âš ï¸ IMPORTANT DISCLAIMER

**EDUCATIONAL AND ETHICAL USE ONLY**

This security audit report has been generated by an automated tool designed for educational purposes and authorized security assessments. This tool should **NEVER** be used to:

- Exploit vulnerabilities in smart contracts without explicit permission
- Attack or compromise blockchain networks or applications
- Engage in any malicious activities

**Responsible Disclosure:** If vulnerabilities are discovered in deployed contracts, please follow responsible disclosure practices by contacting the contract owners or development teams first, allowing them time to address issues before any public disclosure.

**Legal Notice:** Users are solely responsible for ensuring their use of this tool complies with applicable laws and regulations. The tool developers assume no responsibility for misuse."""
    
    def _generate_executive_summary(self, findings: List[Finding]) -> str:
        """Generate executive summary with key statistics."""
        if not findings:
            return """## Executive Summary

âœ… **No security vulnerabilities detected** in the analyzed smart contract code.

The automated analysis did not identify any common security issues or anti-patterns. However, this does not guarantee the contract is completely secure - manual review by experienced auditors is always recommended for production deployments."""
        
        # Calculate severity statistics
        severity_counts = {'Critical': 0, 'High': 0, 'Medium': 0, 'Low': 0, 'Info': 0}
        for finding in findings:
            severity_counts[finding.severity] = severity_counts.get(finding.severity, 0) + 1
        
        total_findings = len(findings)
        critical_high = severity_counts['Critical'] + severity_counts['High']
        
        # Determine overall risk level
        if severity_counts['Critical'] > 0:
            risk_level = "ðŸ”´ **CRITICAL RISK**"
            risk_description = "Critical vulnerabilities detected that could lead to significant financial loss or complete contract compromise."
        elif severity_counts['High'] > 0:
            risk_level = "ðŸŸ  **HIGH RISK**"
            risk_description = "High-severity vulnerabilities detected that could lead to financial loss or security breaches."
        elif severity_counts['Medium'] > 0:
            risk_level = "ðŸŸ¡ **MEDIUM RISK**"
            risk_description = "Medium-severity issues detected that should be addressed before deployment."
        elif severity_counts['Low'] > 0:
            risk_level = "ðŸŸ¢ **LOW RISK**"
            risk_description = "Low-severity issues detected. Consider addressing for improved security posture."
        else:
            risk_level = "â„¹ï¸ **INFORMATIONAL**"
            risk_description = "Only informational findings detected. No significant security concerns identified."
        
        return f"""## Executive Summary

**Risk Level:** {risk_level}

{risk_description}

### Summary Statistics

| Severity | Count |
|----------|--------|
| Critical | {severity_counts['Critical']} |
| High     | {severity_counts['High']} |
| Medium   | {severity_counts['Medium']} |
| Low      | {severity_counts['Low']} |
| Info     | {severity_counts['Info']} |
| **Total** | **{total_findings}** |

### Key Findings

{self._generate_key_findings_summary(findings, critical_high)}"""
    
    def _generate_key_findings_summary(self, findings: List[Finding], critical_high_count: int) -> str:
        """Generate a brief summary of the most important findings."""
        if critical_high_count == 0:
            return "- No critical or high-severity vulnerabilities identified\n- Review medium and low-severity findings for security improvements"
        
        key_findings = []
        critical_findings = [f for f in findings if f.severity == 'Critical']
        high_findings = [f for f in findings if f.severity == 'High']
        
        for finding in critical_findings[:3]:  # Top 3 critical
            key_findings.append(f"- **CRITICAL**: {finding.vulnerability_type} - {finding.description}")
        
        for finding in high_findings[:3]:  # Top 3 high
            key_findings.append(f"- **HIGH**: {finding.vulnerability_type} - {finding.description}")
        
        if len(critical_findings) + len(high_findings) > 6:
            key_findings.append(f"- ... and {len(critical_findings) + len(high_findings) - 6} more high/critical issues")
        
        return '\n'.join(key_findings)
    
    def _generate_scope_section(self, source: str, code: str) -> str:
        """Generate audit scope section."""
        lines_of_code = len(code.split('\n'))
        
        return f"""## Audit Scope

### Code Analysis Target
- **Source:** {source}
- **Lines of Code:** {lines_of_code:,}
- **Analysis Type:** Automated static analysis
- **Languages:** Solidity

### Analysis Coverage
- âœ… Common vulnerability patterns (Reentrancy, Access Control, etc.)
- âœ… Solidity best practice violations
- âœ… Gas optimization opportunities
- âœ… Code quality issues
- âš ï¸ **Note:** This automated analysis supplements but does not replace manual security review"""
    
    def _generate_methodology_section(self) -> str:
        """Generate methodology section explaining the analysis approach."""
        return """## Methodology

### Automated Static Analysis
The security analysis was performed using a combination of:

1. **Pattern-Based Detection**
   - Regex pattern matching for common vulnerability patterns
   - Analysis of Solidity-specific security anti-patterns
   - Detection of deprecated or dangerous function usage

2. **Slither Integration** (when available)
   - Advanced static analysis using the Slither framework
   - Control flow and data flow analysis
   - Cross-function vulnerability detection

3. **Best Practice Checks**
   - Solidity version compatibility issues
   - Gas optimization opportunities
   - Code quality and maintainability issues

### Vulnerability Classification
Findings are classified using the following severity levels:

- **Critical:** Issues that can lead to immediate loss of funds or complete contract compromise
- **High:** Serious vulnerabilities that could lead to significant financial loss or security breaches
- **Medium:** Issues that could potentially be exploited under specific conditions
- **Low:** Minor issues that should be addressed for improved security posture
- **Info:** Informational findings about code quality and best practices

### References
- [SWC Registry](https://swcregistry.io/) - Smart Contract Weakness Classification
- [CWE](https://cwe.mitre.org/) - Common Weakness Enumeration
- [Consensys Best Practices](https://consensys.github.io/smart-contract-best-practices/)"""
    
    def _generate_findings_section(self, findings: List[Finding]) -> str:
        """Generate detailed findings section."""
        if not findings:
            return """## Findings

No security vulnerabilities or issues were identified during the automated analysis."""
        
        findings_content = ["## Findings"]
        
        # Group findings by severity
        severity_groups = {'Critical': [], 'High': [], 'Medium': [], 'Low': [], 'Info': []}
        for finding in findings:
            severity_groups[finding.severity].append(finding)
        
        finding_counter = 1
        
        for severity in ['Critical', 'High', 'Medium', 'Low', 'Info']:
            if not severity_groups[severity]:
                continue
                
            # Add severity section header
            severity_icon = {
                'Critical': 'ðŸ”´',
                'High': 'ðŸŸ ', 
                'Medium': 'ðŸŸ¡',
                'Low': 'ðŸ”µ',
                'Info': 'â„¹ï¸'
            }
            
            findings_content.append(f"### {severity_icon[severity]} {severity} Severity Findings")
            
            # Add each finding in this severity group
            for finding in severity_groups[severity]:
                finding_section = self._format_finding(finding, finding_counter)
                findings_content.append(finding_section)
                finding_counter += 1
        
        return '\n\n'.join(findings_content)
    
    def _format_finding(self, finding: Finding, finding_id: int) -> str:
        """Format a single finding for the report."""
        # Build references section
        references = []
        if finding.cwe_id:
            references.append(f"[{finding.cwe_id}](https://cwe.mitre.org/data/definitions/{finding.cwe_id[4:]}.html)")
        if finding.swc_id:
            references.append(f"[{finding.swc_id}](https://swcregistry.io/docs/{finding.swc_id})")
        
        ref_text = f"**References:** {', '.join(references)}" if references else ""
        
        line_info = f"**Line:** {finding.line_number}" if finding.line_number else "**Line:** N/A"
        
        return f"""#### Finding #{finding_id}: {finding.vulnerability_type}

**Severity:** {finding.severity}  
{line_info}  
{ref_text}

**Description:**  
{finding.description}

**Technical Explanation:**  
{finding.explanation}

**Code Snippet:**
```solidity
{finding.code_snippet}
```

**Recommendation:**  
{finding.recommendation}

---"""
    
    def _generate_recommendations_section(self, findings: List[Finding]) -> str:
        """Generate general recommendations section."""
        if not findings:
            return """## Recommendations

### General Security Best Practices

Even though no vulnerabilities were detected, consider implementing these security best practices:

1. **Use Latest Solidity Version:** Keep Solidity compiler updated to benefit from latest security features
2. **Implement Access Controls:** Use OpenZeppelin's Ownable or AccessControl for function restrictions
3. **Add Reentrancy Protection:** Consider using ReentrancyGuard even if not immediately needed
4. **Comprehensive Testing:** Implement unit tests covering edge cases and security scenarios
5. **Professional Audit:** Consider professional manual audit before mainnet deployment"""
        
        # Extract unique recommendation types
        critical_recs = []
        general_recs = []
        
        critical_findings = [f for f in findings if f.severity in ['Critical', 'High']]
        
        if critical_findings:
            critical_recs.append("**IMMEDIATE ACTION REQUIRED:** Address all Critical and High severity findings before any deployment")
        
        # Add severity-specific recommendations
        severity_counts = {}
        for finding in findings:
            severity_counts[finding.severity] = severity_counts.get(finding.severity, 0) + 1
        
        if severity_counts.get('Critical', 0) > 0:
            critical_recs.append("- Review and fix all reentrancy, access control, and fund-loss vulnerabilities")
        
        if severity_counts.get('High', 0) > 0:
            critical_recs.append("- Implement proper input validation and error handling")
        
        # General recommendations
        general_recs.extend([
            "1. **Code Review:** Conduct thorough manual code review by experienced developers",
            "2. **Testing:** Implement comprehensive unit and integration tests",
            "3. **Gradual Deployment:** Consider deploying to testnets first",
            "4. **Monitoring:** Implement transaction monitoring and anomaly detection",
            "5. **Bug Bounty:** Consider running a bug bounty program before mainnet launch",
            "6. **Documentation:** Maintain clear documentation of security assumptions and design decisions"
        ])
        
        critical_section = ""
        if critical_recs:
            critical_section = f"### ðŸš¨ Critical Recommendations\n\n" + '\n'.join(critical_recs) + "\n\n"
        
        general_section = f"### General Security Recommendations\n\n" + '\n'.join(general_recs)
        
        return f"""## Recommendations

{critical_section}{general_section}"""
    
    def _generate_references_section(self) -> str:
        """Generate references and further reading section."""
        return """## References and Further Reading

### Security Resources
- [Consensys Smart Contract Best Practices](https://consensys.github.io/smart-contract-best-practices/)
- [OpenZeppelin Security Documentation](https://docs.openzeppelin.com/contracts/4.x/security)
- [SWC Registry](https://swcregistry.io/) - Smart Contract Weakness Classification
- [Ethereum Smart Contract Security Best Practices](https://github.com/ConsenSys/smart-contract-best-practices)

### Educational Platforms
- [Ethernaut](https://ethernaut.openzeppelin.com/) - Smart contract hacking challenges
- [Damn Vulnerable DeFi](https://www.damnvulnerabledefi.xyz/) - DeFi security challenges
- [Capture The Ether](https://capturetheether.com/) - Ethereum security puzzles

### Tools and Frameworks
- [Slither](https://github.com/crytic/slither) - Static analysis framework
- [MythX](https://mythx.io/) - Security analysis platform
- [Securify](https://securify.chainsecurity.com/) - Formal verification tool
- [OpenZeppelin](https://openzeppelin.com/) - Secure smart contract library

### Standards and Classifications
- [CWE](https://cwe.mitre.org/) - Common Weakness Enumeration
- [OWASP](https://owasp.org/www-project-smart-contract-top-10/) - Smart Contract Top 10"""
    
    def _generate_appendix_section(self, code: str, code_hash: str) -> str:
        """Generate appendix with technical details."""
        lines_of_code = len(code.split('\n'))
        
        return f"""## Appendix

### Technical Details
- **Analysis Tool:** {self.tool_name} v{self.tool_version}
- **Analysis Date:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S UTC')}
- **Code Hash:** `{code_hash}`
- **Lines of Code:** {lines_of_code:,}

### Methodology Notes
This report was generated using automated static analysis techniques. While comprehensive, automated analysis may not detect all possible vulnerabilities, especially those requiring complex business logic understanding or multi-contract interactions.

**Limitations:**
- Does not analyze external contract dependencies
- May not detect complex business logic vulnerabilities
- Cannot verify economic model security
- Does not test runtime behavior

### Responsible Disclosure
If you discover vulnerabilities in deployed smart contracts based on this analysis, please:

1. **Do not exploit** the vulnerability for personal gain
2. **Contact the contract owners** immediately through appropriate channels
3. **Allow reasonable time** for the issue to be addressed
4. **Follow coordinated disclosure** practices
5. **Document your findings** professionally and constructively

Remember: The goal of security research is to make the ecosystem safer for everyone."""
    
    def generate_json_report(self, code: str, findings: List[Finding], source: str, code_hash: str) -> Dict:
        """
        Generate a structured JSON report for machine processing.
        
        Args:
            code: The analyzed Solidity source code
            findings: List of security findings from the analysis
            source: Description of the code source
            code_hash: SHA256 hash of the analyzed code
            
        Returns:
            Dictionary containing structured report data
        """
        # Calculate summary statistics
        severity_counts = {'Critical': 0, 'High': 0, 'Medium': 0, 'Low': 0, 'Info': 0}
        for finding in findings:
            severity_counts[finding.severity] = severity_counts.get(finding.severity, 0) + 1
        
        return {
            'metadata': {
                'tool_name': self.tool_name,
                'tool_version': self.tool_version,
                'analysis_timestamp': datetime.now().isoformat(),
                'source': source,
                'code_hash': code_hash,
                'lines_of_code': len(code.split('\n'))
            },
            'summary': {
                'total_findings': len(findings),
                'severity_breakdown': severity_counts,
                'risk_level': self._calculate_risk_level(severity_counts)
            },
            'findings': [finding.to_dict() for finding in findings],
            'disclaimer': {
                'educational_use_only': True,
                'responsible_disclosure_required': True,
                'no_exploit_code_included': True,
                'manual_review_recommended': True
            }
        }
    
    def _calculate_risk_level(self, severity_counts: Dict[str, int]) -> str:
        """Calculate overall risk level based on findings."""
        if severity_counts['Critical'] > 0:
            return 'Critical'
        elif severity_counts['High'] > 0:
            return 'High'
        elif severity_counts['Medium'] > 0:
            return 'Medium'
        elif severity_counts['Low'] > 0:
            return 'Low'
        else:
            return 'Informational'